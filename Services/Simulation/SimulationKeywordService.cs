using System;
using System.Text;
using SpaceClaim.Api.V252.MXDigitalTwinModeller.Models.Simulation;

namespace SpaceClaim.Api.V252.MXDigitalTwinModeller.Services.Simulation
{
    public static class SimulationKeywordService
    {
        private static SimulationParameters _current;

        public static SimulationParameters Current
        {
            get { return _current ?? (_current = new SimulationParameters()); }
            set { _current = value; }
        }

        public static string GenerateKeywords(SimulationParameters p)
        {
            if (p == null) p = new SimulationParameters();

            switch (p.Type)
            {
                case SimulationType.ModalAnalysis:
                    return GenerateModalKeywords(p);
                default:
                    return "$ Unsupported simulation type\n*END\n";
            }
        }

        /// <summary>
        /// 제어 카드만 생성 (*KEYWORD, *TITLE, *END 없이).
        /// .k 파일 내보내기 시 기존 메쉬 파일에 삽입용.
        /// </summary>
        public static string GenerateControlCardsOnly(SimulationParameters p)
        {
            string full = GenerateKeywords(p);

            // *KEYWORD ~ *TITLE 이후 첫 빈 줄까지의 헤더 제거
            var lines = full.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);
            var sb = new StringBuilder();
            bool pastHeader = false;
            foreach (string line in lines)
            {
                string trimmed = line.TrimStart();
                if (!pastHeader)
                {
                    if (trimmed.StartsWith("*KEYWORD", StringComparison.OrdinalIgnoreCase) ||
                        trimmed.StartsWith("*TITLE", StringComparison.OrdinalIgnoreCase))
                        continue;
                    // 타이틀 텍스트 행 (헤더 직후 비-키워드, 비-코멘트 행)
                    if (!trimmed.StartsWith("*") && !trimmed.StartsWith("$") && !pastHeader)
                        continue;
                    pastHeader = true;
                }
                // *END 제거
                if (trimmed.Equals("*END", StringComparison.OrdinalIgnoreCase))
                    continue;
                sb.AppendLine(line);
            }
            return sb.ToString();
        }

        // ═══════════════════════════════════════════════════════════════
        //  Modal Analysis Keyword Generation
        // ═══════════════════════════════════════════════════════════════

        private static string GenerateModalKeywords(SimulationParameters p)
        {
            var sb = new StringBuilder();

            // ── Header ──
            sb.AppendLine("*KEYWORD");
            sb.AppendLine("*TITLE");
            sb.AppendLine(p.Title ?? "Modal_Analysis");
            sb.AppendLine("$");
            sb.AppendLine("$==========================================================================");
            sb.AppendLine("$  LS-DYNA Implicit Eigenvalue (Modal) Analysis Control Cards");
            sb.AppendLine("$  Generated by MX Digital Twin Modeller");
            sb.AppendLine("$==========================================================================");

            // ── *CONTROL_IMPLICIT_GENERAL ──
            sb.AppendLine("$");
            sb.AppendLine("$--- Switch to implicit, eigenvalue mode ---");
            sb.AppendLine("$");
            sb.AppendLine("*CONTROL_IMPLICIT_GENERAL");
            sb.AppendLine("$#  imflag       dt0    imform      nsbs       igs     cnstn      form    zero_v");
            int igs = p.GeometricStiffness ? 2 : 0;
            sb.AppendLine(I10(1) + F10(0.0) + I10(p.ImplicitFormulation) + I10(1) + I10(igs) + I10(0) + I10(0) + I10(0));

            // ── *CONTROL_IMPLICIT_EIGENVALUE ──
            sb.AppendLine("$");
            sb.AppendLine("$--- Eigenvalue extraction parameters ---");
            sb.AppendLine("$  NEIG    : Number of eigenvalues to extract");
            sb.AppendLine("$  LFLAG=2 : Lower bound in frequency (Hz), 0=none");
            sb.AppendLine("$  RFLAG=2 : Upper bound in frequency (Hz), 0=none");
            sb.AppendLine("$  EIGMTH  : 2=Lanczos, 3=Inverse Power, 101=BCSLIB-EXT");
            sb.AppendLine("$");
            sb.AppendLine("*CONTROL_IMPLICIT_EIGENVALUE");
            sb.AppendLine("$#    neig    center     lflag    lftend     rflag    rhtend    eigmth    shfscl");
            int lflag = p.MinFrequency > 0 ? 2 : 0;
            int rflag = p.MaxFrequency > 0 ? 2 : 0;
            sb.AppendLine(I10(p.NumModes) + F10(0.0) + I10(lflag) + F10(p.MinFrequency)
                        + I10(rflag) + F10(p.MaxFrequency) + I10(p.EigenvalueMethod) + F10(0.0));

            // ── *CONTROL_IMPLICIT_SOLVER ──
            sb.AppendLine("$");
            sb.AppendLine("$--- Implicit solver selection ---");
            sb.AppendLine("$  LSOLVR : 2=Multi-frontal Sparse, 4=PARDISO, 6=MUMPS");
            sb.AppendLine("$  NEGEV  : 0=stop, 1=warn, 2=allow negative eigenvalues");
            sb.AppendLine("$  AUTOSPC: 1=auto single-point constraints for singular DOF");
            sb.AppendLine("$");
            sb.AppendLine("*CONTROL_IMPLICIT_SOLVER");
            sb.AppendLine("$#  lsolvr    lprint     negev     order      drcm    drcprm   autospc   autotol");
            sb.AppendLine(I10(p.SolverType) + I10(0) + I10(p.NegativeEigenvalue) + I10(0)
                        + I10(4) + F10(0.0) + I10(p.AutoSPC ? 1 : 0) + F10(0.0));

            // ── *CONTROL_IMPLICIT_AUTO ──
            sb.AppendLine("$");
            sb.AppendLine("$--- Implicit auto time stepping (for static preload) ---");
            sb.AppendLine("$");
            sb.AppendLine("*CONTROL_IMPLICIT_AUTO");
            sb.AppendLine("$#   iauto    iteopt    itewin     dtmin     dtmax     dtexp     kfail    kcycle");
            sb.AppendLine(I10(1) + I10(11) + I10(5) + F10(0.0) + F10(0.0) + F10(0.0) + I10(0) + I10(0));

            // ── *CONTROL_TERMINATION ──
            sb.AppendLine("$");
            sb.AppendLine("$--- Analysis termination ---");
            sb.AppendLine("$");
            sb.AppendLine("*CONTROL_TERMINATION");
            sb.AppendLine("$#  endtim    endcyc     dtmin    endeng    endmas     nosol");
            sb.AppendLine(F10(0.0) + I10(0) + F10(0.0) + F10(0.0) + F10(1.0e8) + I10(0));

            // ════════════════════════════════════════════════════════════
            //  OUTPUT CONTROL
            // ════════════════════════════════════════════════════════════
            sb.AppendLine("$");
            sb.AppendLine("$==========================================================================");
            sb.AppendLine("$  OUTPUT CONTROL");
            sb.AppendLine("$==========================================================================");

            if (p.OutputEigout)
            {
                sb.AppendLine("$");
                sb.AppendLine("$--- Binary eigenvalue output (d3eigv) ---");
                sb.AppendLine("$");
                sb.AppendLine("*DATABASE_BINARY_D3EIGV");
                sb.AppendLine("$#      dt      lcdt      beam     npltc    psetid");
                sb.AppendLine(F10(0.0) + I10(0) + I10(0) + I10(0) + I10(0));
            }

            if (p.OutputD3plot)
            {
                sb.AppendLine("$");
                sb.AppendLine("$--- Binary plot output (d3plot + d3eigv) ---");
                sb.AppendLine("$");
                sb.AppendLine("*DATABASE_BINARY_D3PLOT");
                sb.AppendLine("$#      dt      lcdt      beam     npltc    psetid");
                sb.AppendLine(F10(0.0) + I10(0) + I10(0) + I10(0) + I10(0));
            }

            if (p.OutputNodeout)
            {
                sb.AppendLine("$");
                sb.AppendLine("*DATABASE_NODOUT");
                sb.AppendLine("$#      dt    binary      lcur     ioopt   option1   option2");
                sb.AppendLine(F10(0.0) + I10(0) + I10(0) + I10(1) + F10(0.0) + I10(0));
            }

            if (p.OutputElout)
            {
                sb.AppendLine("$");
                sb.AppendLine("*DATABASE_ELOUT");
                sb.AppendLine("$#      dt    binary      lcur     ioopt");
                sb.AppendLine(F10(0.0) + I10(0) + I10(0) + I10(1));
            }

            // ── *DATABASE_EXTENT_BINARY ──
            sb.AppendLine("$");
            sb.AppendLine("$--- Binary output extent (what fields to include) ---");
            sb.AppendLine("$");
            sb.AppendLine("*DATABASE_EXTENT_BINARY");
            sb.AppendLine("$#   neiph     neips    maxint    strflg    sigflg    epsflg    rltflg    engflg");
            sb.AppendLine(I10(0) + I10(0) + I10(3) + I10(1) + I10(1) + I10(1) + I10(1) + I10(1));
            sb.AppendLine("$#  cmpflg    ieverp    beamip     dcomp      shge     stssz    n3thdt   ialemat");
            sb.AppendLine(I10(0) + I10(0) + I10(0) + I10(1) + I10(1) + I10(0) + I10(0) + I10(0));
            sb.AppendLine("$# nintsld   pkp_sen      sclp    unused     msscl     therm    intout    nodout");
            sb.AppendLine(I10(0) + I10(0) + F10(1.0) + I10(0) + I10(0) + I10(0) + S10("STRESS") + S10("STRESS"));

            // ── *CONTROL_OUTPUT ──
            sb.AppendLine("$");
            sb.AppendLine("$--- General output control ---");
            sb.AppendLine("$");
            sb.AppendLine("*CONTROL_OUTPUT");
            sb.AppendLine("$#   npopt    netefq     nrefup    iaccop     optefq    ipnint    iketefq");
            sb.AppendLine(I10(0) + I10(0) + I10(0) + I10(0) + F10(0.0) + I10(0) + I10(0));

            // ════════════════════════════════════════════════════════════
            //  ADDITIONAL CONTROLS
            // ════════════════════════════════════════════════════════════
            sb.AppendLine("$");
            sb.AppendLine("$==========================================================================");
            sb.AppendLine("$  ADDITIONAL CONTROLS");
            sb.AppendLine("$==========================================================================");

            if (p.ControlEnergy)
            {
                sb.AppendLine("$");
                sb.AppendLine("$--- Energy computation (hourglass, stonewall, sliding, Rayleigh) ---");
                sb.AppendLine("$");
                sb.AppendLine("*CONTROL_ENERGY");
                sb.AppendLine("$#    hgen      rwen    slnten     rylen");
                sb.AppendLine(I10(2) + I10(2) + I10(2) + I10(2));
            }

            if (p.ControlHourglass)
            {
                sb.AppendLine("$");
                sb.AppendLine("$--- Hourglass control ---");
                sb.AppendLine("$  IHQ: 6=Belytschko-Bindeman assumed strain (shells)");
                sb.AppendLine("$  QH : Hourglass coefficient (default 0.10)");
                sb.AppendLine("$");
                sb.AppendLine("*CONTROL_HOURGLASS");
                sb.AppendLine("$#     ihq        qh");
                sb.AppendLine(I10(p.HourglassType) + F10(p.HourglassCoeff));
            }

            if (p.ControlAccuracy)
            {
                sb.AppendLine("$");
                sb.AppendLine("$--- Accuracy / objectivity settings ---");
                sb.AppendLine("$  OSU=1 : Objective stress update (2nd order accurate)");
                sb.AppendLine("$  INN=4 : Invariant node numbering for shells + solids");
                sb.AppendLine("$");
                sb.AppendLine("*CONTROL_ACCURACY");
                sb.AppendLine("$#     osu       inn    pidosu      iacc");
                sb.AppendLine(I10(1) + I10(4) + I10(0) + I10(0));
            }

            // ── *CONTROL_BULK_VISCOSITY ──
            sb.AppendLine("$");
            sb.AppendLine("$--- Bulk viscosity (standard defaults) ---");
            sb.AppendLine("$");
            sb.AppendLine("*CONTROL_BULK_VISCOSITY");
            sb.AppendLine("$#      q1        q2      type     btype");
            sb.AppendLine(F10(1.5) + F10(0.06) + I10(-2) + I10(0));

            // ── *CONTROL_SHELL (important for shell-dominant models) ──
            sb.AppendLine("$");
            sb.AppendLine("$--- Shell element control ---");
            sb.AppendLine("$  WRPANG=20 : Shell warping angle limit");
            sb.AppendLine("$  ESORT =1  : Auto-sort shell formulations for accuracy");
            sb.AppendLine("$  ISTUPD=1  : Shell thickness update (large strain)");
            sb.AppendLine("$  THEORY=2  : BWC (Belytschko-Wong-Chiang) shell theory");
            sb.AppendLine("$");
            sb.AppendLine("*CONTROL_SHELL");
            sb.AppendLine("$#  wrpang    esort     irnxx    istupd    theory       bwc     miter      proj");
            sb.AppendLine(F10(20.0) + I10(1) + I10(-1) + I10(1) + I10(2) + I10(2) + I10(1) + I10(0));

            // ── *CONTROL_SOLID (important for solid-dominant models) ──
            sb.AppendLine("$");
            sb.AppendLine("$--- Solid element control ---");
            sb.AppendLine("$  ESORT=1 : Auto-sort solid formulations");
            sb.AppendLine("$");
            sb.AppendLine("*CONTROL_SOLID");
            sb.AppendLine("$#   esort    fmatrx    niptets      swlocl    ptefct");
            sb.AppendLine(I10(1) + I10(0) + I10(4) + I10(0) + I10(0));

            // ── End ──
            sb.AppendLine("$");
            sb.AppendLine("$==========================================================================");
            sb.AppendLine("$  NOTE: Material (*MAT_), mesh (*ELEMENT_, *NODE), boundary conditions");
            sb.AppendLine("$  (*BOUNDARY_SPC_), and load (*LOAD_) cards are in separate .k includes.");
            sb.AppendLine("$==========================================================================");
            sb.AppendLine("$");
            sb.AppendLine("*END");

            return sb.ToString();
        }

        // ═══════════════════════════════════════════════════════════════
        //  LS-DYNA Card Formatters (10-char fixed-width fields)
        // ═══════════════════════════════════════════════════════════════

        private static string I10(int v)
        {
            return v.ToString().PadLeft(10);
        }

        private static string F10(double v)
        {
            if (v == 0.0) return "       0.0";

            double abs = Math.Abs(v);
            string s;

            if (abs >= 1e7 || abs < 0.01)
                s = v.ToString("0.000E+0");
            else if (abs >= 1000)
                s = v.ToString("F1");
            else if (abs >= 1)
                s = v.ToString("F4");
            else
                s = v.ToString("F5");

            if (s.Length > 10)
                s = v.ToString("0.0E+0");
            if (s.Length > 10)
                s = s.Substring(0, 10);

            return s.PadLeft(10);
        }

        private static string S10(string v)
        {
            if (v == null) v = "";
            if (v.Length > 10) v = v.Substring(0, 10);
            return v.PadLeft(10);
        }
    }
}
